#======================================================================================
# flush ruleset
#======================================================================================
flush

#======================================================================================
# general purpose rules 1...1000
#======================================================================================
add 100 allow pfsync from any to any
add 110 allow carp from any to any
# layer 2: pass ARP
add 120 pass layer2 mac-type arp,rarp
# OPNsense requires for WPA
add 130 pass layer2 mac-type 0x888e,0x88c7
# PPP Over Ethernet Session Stage/Discovery Stage
add 140 pass layer2 mac-type 0x8863,0x8864
# layer 2: block anything else non-IP(v4/v6)
add 150 deny layer2 not mac-type ip,ipv6

# allow traffic send from localhost
add 200 skipto 60000 ipv6 from ::1 to any
add 201 skipto 60000 ipv4 from 127.0.0.0/8 to any
add 202 skipto 60000 ipv6 from any to ::1
add 203 skipto 60000 ipv4 from any to 127.0.0.0/8

#======================================================================================
# traffic shaping section, authorized traffic
#======================================================================================
add 60000 return via any

{% if helpers.exists('OPNsense.TrafficShaper.rules.rule') %}
{# Iterate through rules, sorted by sequence as defined in the model XML #}
{% for rule in helpers.toList('OPNsense.TrafficShaper.rules.rule', 'sequence', 'int') %}
{# Basic checks for enabled rule, target, interfaces etc. #}
{%    if helpers.getUUIDtag(rule.target) in ['pipe','queue'] and rule.enabled|default('0') == '1' and helpers.physical_interface(rule.interface) %}
{%        set target_object = helpers.getUUID(rule.target) %}
{%        set target_enabled = target_object.enabled|default('0') == '1' %}
{%        set pipe_enabled = (helpers.getUUIDtag(rule.target) == 'pipe' or helpers.getUUID(helpers.getUUID(target_object.pipe)).enabled|default('0') == '1') %}
{%        if target_enabled and pipe_enabled %}

{# --- Resolve Source and Destination Addresses --- #}
{% set sources = helpers.resolve_shaper_address(rule.source) %}
{% set destinations = helpers.resolve_shaper_address(rule.destination) %}
{# --- Max items for sequence offset calculation (needs to be > alias limit) --- #}
{% set MAX_EXPANSION_PER_SIDE = 1001 %}

{# --- Check for Resolution Errors (helper returns None) --- #}
{% if sources is not none and destinations is not none %}
    {# --- Nested Loops for Cartesian Product --- #}
    {% for src_idx, src in enumerate(sources) %}
        {% for dst_idx, dst in enumerate(destinations) %}
            {# --- Generate Unique Sequence Number --- #}
            {% set base_sequence = 61000 %} {# Start high to avoid system rules #}
            {% set rule_seq_offset = (rule.sequence|int) * MAX_EXPANSION_PER_SIDE %} {# Fixed: Use single multiplier #}
            {% set expansion_offset = src_idx * 1000 + dst_idx %} {# Unique offset within this rule's expansion #}
            {% set seq_num = [base_sequence + rule_seq_offset + expansion_offset, 65534]|min %} {# Final number, capped #}

            {# --- Handle NOT Flags --- #}
            {% set src_not_flag = "not " if rule.source_not|default('0') == '1' and src != 'any' else "" %}
            {% set dst_not_flag = "not " if rule.destination_not|default('0') == '1' and dst != 'any' else "" %}

            {# --- Generate Rule Parameters --- #}
            {% set rule_comment = "// Rule " + rule['@uuid'] + " expanded src:" + src + " dst:" + dst %}
            {% set target_type = helpers.getUUIDtag(rule.target) %}
            {% set target_number = target_object.number %}
            {% set proto = rule.proto.split('_')[0] %}
            {% set src_port = rule.src_port %}
            {% set dst_port = rule.dst_port %}
            {% set direction = rule.direction %}
            {% set iface1 = helpers.physical_interface(rule.interface) %}
            {% set iface2 = helpers.physical_interface(rule.interface2) if rule.interface2 else None %}
            {% set tcp_flags = rule.proto.split('_')[2]|default('') + " tcpflags ack" if rule.proto.split('_')[1]|default('') == 'ack' else "" %}
            {% set iplen_part = "iplen 1-" + rule.iplen if rule.iplen|default('') != '' else "" %}
            {% set dscp_part = "dscp " + rule.dscp if rule.dscp|default('') != '' else "" %}

            {# --- Generate the ipfw add command(s) --- #}
            {% if iface2 %}
                {# 2 interface rule pair #}
                {% if direction == 'in' or not direction %}
add {{ seq_num }} {{ target_type }} {{ target_number }} {{ proto }} from {{ src_not_flag }}{{ src }} to {{ dst_not_flag }}{{ dst }} src-port {{ src_port }} dst-port {{ dst_port }} recv {{ iface1 }} {{ tcp_flags }} {{ iplen_part }} {{ dscp_part }} xmit {{ iface2 }} {{ rule_comment[0:70] }}
                {% endif %}
                {% if direction == 'out' or not direction %}
{# Ensure uniqueness if both directions active for same src/dst pair #}
add {{ [seq_num + 1, 65534]|min }} {{ target_type }} {{ target_number }} {{ proto }} from {{ src_not_flag }}{{ src }} to {{ dst_not_flag }}{{ dst }} src-port {{ src_port }} dst-port {{ dst_port }} xmit {{ iface1 }} {{ tcp_flags }} {{ iplen_part }} {{ dscp_part }} recv {{ iface2 }} {{ rule_comment[0:70] }}
                {% endif %}
            {% else %}
                {# Single interface rule #}
add {{ seq_num }} {{ target_type }} {{ target_number }} {{ proto }} from {{ src_not_flag }}{{ src }} to {{ dst_not_flag }}{{ dst }} src-port {{ src_port }} dst-port {{ dst_port }} {{ direction }} {{ tcp_flags }} {{ iplen_part }} {{ dscp_part }} via {{ iface1 }} {{ rule_comment[0:70] }}
            {% endif %}
        {% endfor %} {# end dst loop #}
    {% endfor %} {# end src loop #}
{% else %}
{# Rule {{ rule.description|default("unnamed") }} (UUID {{ rule['@uuid'] }}) skipped due to source/destination alias resolution errors. Check system logs. #}
{% endif %} {# End sources/destinations check #}

{%        endif %} {# End target/pipe enabled check #}
{%    endif %} {# End basic rule enabled/interface check #}
{% endfor %} {# End rule loop #}
{% endif %} {# End rules exist check #}

# pass authorized
add 65533 pass ip from any to any

# block all unmatched
add 65534 deny all from any to any
